<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Examples for different skills of testing.">
	<title>DEMOTESTING</title>
	<link rel="stylesheet" href="https://unpkg.com/purecss@2.0.3/build/pure-min.css" integrity="sha384-cg6SkqEOCV1NbJoCu11+bm0NvBRc8IYLRGXkmNrqUBfTjmMYwNKPWBTIKyw9mHNJ" crossorigin="anonymous">
	<link rel="stylesheet" href="https://unpkg.com/purecss@2.0.3/build/grids-responsive-min.css">
	<link rel="stylesheet" href="https://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css">
	<link rel="stylesheet" href="styles.css"> </head>

<body>
	<div class="header">
		<a name="begining"></a>
		<div class="home-menu pure-menu pure-menu-horizontal pure-menu-fixed"> <a class="pure-menu-heading" href="https://hh.ru/resume/fa9fc006ff02b3b16c0039ed1f386661516c36">Мой профиль на hh.ru</a>
			<ul class="pure-menu-list">
				<li class="pure-menu-item"><a href="#forms" class="pure-menu-link">Обработка форм</a></li>
			</ul>
		</div>
	</div>
	<div class="splash-container">
		<div class="splash">
			<h1 class="splash-head">DEMO TESTING </h1>
			<p class="splash-subhead"> Этот сайт является демонстрацией навыков работы с SQL, JavaScript, Mocha &amp; Chai, Postman. 
				<br/>в интерактивном формате </p>
			<p> <a href="#begin" class="pure-button pure-button-primary">Начать</a> </p>
		</div>
	</div>
	<div class="content-wrapper">
		<div class="content">
			<a name="begin"></a>
			<h2 class="content-head is-center">Технологии проекта</h2>
			<div class="pure-g">
				<div class="l-box pure-u-1 pure-u-md-1-2 pure-u-lg-1-4">
					<h3 class="content-subhead">
                   <i class="fa fa-check-square-o"></i>
                    SQl &amp; PostgreSQL
                </h3>
					<p> Для обработки форм составлены SQL шаблоны запросов, которые производят запись и чтение данных таблицы. В запросах используются данные, которые вводит пользователь. СУБД проекта - PostgreSQL. </p>
				</div>
				<div class="l-box pure-u-1 pure-u-md-1-2 pure-u-lg-1-4">
					<h3 class="content-subhead">
                   <i class="fa fa-check-square-o"></i>
                    HTML &amp; CSS &amp; JS
                </h3>
					<p> Фронтэнд написан на нативном Javascript, скрипты осуществляют валидацию форм и взаимодействие с сервером. HTML и CSS представляют готовый темплэйт на основе бибилиотеки "Pure CSS".* JS библиотеки и фреймворки: lodash, mocha, chai, ajv, xml2json.</p>
				</div>
				<div class="l-box pure-u-1 pure-u-md-1-2 pure-u-lg-1-4">
					<h3 class="content-subhead">
                   <i class="fa fa-check-square-o"></i>
                    JSON
                </h3>
					<p> Асинхронные POST запросы работают с текстовыми данными и данными в формате JSON. </p>
				</div>
				<div class="l-box pure-u-1 pure-u-md-1-2 pure-u-lg-1-4">
					<h3 class="content-subhead">
                    <i class="fa fa-check-square-o"></i>
                    PHP
                </h3>
					<p> Серверные PHP скрипты взаимодействуют с PostgreSQL, отправляют готовые кастомизированные под каждого пользователя SQL запросы. </p>
				</div>
			</div>
		</div>
		<div class="ribbon l-box-lrg pure-g">
			<div class="l-box-lrg is-center pure-u-1 pure-u-md-1-2 pure-u-lg-2-5"> <img width="" alt="File Icons" class="pure-img-responsive" src="img/1.png"> <img width="" alt="File Icons" class="pure-img-responsive" src="img/2.png"> <img width="" alt="File Icons" class="pure-img-responsive" src="img/3.png"> </div>
			<div class="pure-u-1 pure-u-md-1-2 pure-u-lg-3-5">
				<h2 class="content-head content-head-ribbon">Как это работает?</h2>
				<p> Всё просто - нужно почувствовать себя тестировщиком и пройти определённые пользовательские сценарии взаимодействия с данной страницей. Формат "квеста" - прохождения платного психологического опросника для оценки асcертивности (используется простой тест для оценки одного из компонентов "soft skills"). </p>
				<p>Пользователь взаимодействует с сервисом через формы:
					<ol>
						<li>Форма регистрации,</li>
						<li>Форма оплаты,</li>
						<li>Форма опросника,</li>
						<li>Форма для вывода всех данных.</li>
					</ol>
					<p>Для каждой формы в её разделе перечислены позитивный сценарий и варианты негативных сценариев. Предлагаю вам пройти их все. Вы можете придумать свои данные. Также в разделе регистрации приведен пример рандомно сгенерированных данных формы, которые можно использовать в "прогонах" тестовых сценариев. Можно, к примеру, начать с негативных сценариев и пройти по формам, начиная с конца. Или пройти сначала позитивный сценарий, потом перезагрузить страницу и пройти негативные сценарии с новыми данными. Данные пересылаются в теле запросов без дополнительные мер по шифрованию, поэтому рекомендую использовать выдуманные логин, email и т.д. </p>
					<p>Для простоты обработки значений во всех полях форм задано ограничение - в них можно вводить буквы латинского алфавита (верхний и нижний регистр), целые числа от 0 до 9 и символы "@" и ".".
						<p>При выполнении скрипта отправки данных на сервер в консоли браузера выводится текст SQL-запроса, который производит необходимые действия с БД. Каждая форма взаимодействует с БД посредством одного асинхронного POST запроса, поэтому SQL запросы включают подзапросы поиска по id пользователя. Чтобы открыть консоль, нужно в окне браузера нажать F12 и выбрать вкладку Console. Также в консоль выводится информация о статусе основных этапов валидации формы и отправки запроса. Лучше использовать десктопную версию браузера, чтобы увидеть полную информацию по процессам. </p>
						<p class="remark"> *основной фокус состоял в разработке скриптов для работы с БД, поэтому вертска может иметь недостатки отображения, отладка скриптов проводилась в браузерах Google Chrome и iOS Safary (последние версии). </p>
						<p class="remark"> *любой фидбэк по работе сайта отправляйте на t.yamaltdinova@gmail.com. </p>
			</div>
		</div>
		<div class="content">
			<a name="forms"></a>
			<h2 class="content-head is-center">Форма регистрации</h2>
			<div class="pure-g">
				<div class="l-box-lrg pure-u-1 pure-u-md-3-5">
					<h4>Как заполнить:</h4>
					<p> Данная форма регистрирует нового пользователя, который после успешной регистрации может перейти к оплате услуги во второй форме. </p>
					<h4>Ожидаемый сценарий</h4>
					<p>Пользователь корректно заполняет форму по критериям:
						<ul>
							<li>все поля формы нужно заполнить</li>
							<li>в поля можно вводить символы A-Z, a-z, 0-9, @ и . (без пробелов)</li>
							<li>в базу данных можно сохранить нового юзера с уникальным логином и email</li>
						</ul>
						<h4>Негативные сценарии</h4>
						<p>Пользователь:
							<ul>
								<li>пытается отправить форму с пустыми полями (всеми или частью)</li>
								<li>пользователь отправляет данные с другими символами и пробелами</li>
								<li>пользователь пробует сохранить логин или email повторно</li>
							</ul> Во всех этих случаях выводится сообщение об ошибке, и либо блокируется отправка формы, либо не сохраняются введённые данные в БД.
							<br/>Если сохранились корректные данные, по ним можно пройти тест. </div>
				<div class="l-box-lrg pure-u-1 pure-u-md-2-5">
					<form id="form1" onsubmit="return false" class="pure-form pure-form-stacked">
						<fieldset>
							<label for="name1">Логин</label>
							<input id="name1" class="input_login" type="text" placeholder="Ваш логин">
							<label for="email1">Email</label>
							<input id="email1" class="input_email" type="text" placeholder="Ваш email">
							<label for="pswd1">Пароль</label>
							<input id="pswd1" class="input_pswd" type="password" placeholder="Ваш пароль">
							<button id="but1" onclick="return pressSubmit('form1','registration')" class="pure-button">Зарегистрировать</button>
						</fieldset><span class="submit_msg faded_elem"></span> </form>
					<h4>Сгенерированные данные:</h4>
					<p>
						<ul class="random_data">
							<li><b>Логин</b> - <span></span></li>
							<li><b>Email</b> - <span></span></li>
							<li><b>Пароль</b> - <span></span></li>
						</ul>
				</div>
			</div>
			<h2 class="content-head is-center">Форма оплаты</h2>
			<div class="pure-g">
				<div class="l-box-lrg pure-u-1 pure-u-md-3-5">
					<h4>Как заполнить:</h4>
					<p> В данной форме можно оплатить услугу для зарегистрированного пользователя. После успешной оплаты клиент может перейти к прохождению опросника в третьей форме. </p>
					<h4>Ожидаемый сценарий</h4>
					<p>Пользователь корректно заполняет форму по критериям:
						<ul>
							<li>все поля формы нужно заполнить</li>
							<li>в поля можно вводить символы A-Z, a-z, 0-9, @ и . (без пробелов)</li>
							<li>нужно ввести правильный пароль для зарегистрированного пользователя</li>
							<li>на один логин может быть записана одна карта</li>
						</ul>
						<h4>Негативные сценарии</h4>
						<p>Пользователь:
							<ul>
								<li>пытается отправить форму с пустыми полями (всеми или частью)</li>
								<li>отправляет данные с другими символами и пробелами</li>
								<li>пробует провести оплату с логином, которого нет в БД</li>
								<li>вводит некорректный пароль для существующего пользователя</li>
								<li>пробует провести оплату по одному логину повторно</li>
							</ul> Во всех этих случаях выводится сообщение об ошибке, и либо блокируется отправка формы, либо не сохраняются введённые данные в БД.
							<br/>Если сохранились корректные данные, по ним можно пройти тест. </div>
				<div class="l-box-lrg pure-u-1 pure-u-md-2-5">
					<form id="form2" onsubmit="return false" class="pure-form pure-form-stacked">
						<fieldset>
							<label for="name2">Логин</label>
							<input id="name2" class="input_login" type="text" placeholder="Ваш логин">
							<label for="pswd2">Пароль</label>
							<input id="pswd2" class="input_pswd" type="password" placeholder="Ваш пароль">
							<label for="card2">Карта</label>
							<input id="card2" class="input_card" type="text" placeholder="Номер карты">
							<button id="but2" onclick="return pressSubmit('form2','billing')" class="pure-button">Оплатить</button>
						</fieldset><span class="submit_msg faded_elem"></span> </form>
				</div>
			</div>
			<h2 class="content-head is-center">Форма опросника</h2>
			<div class="pure-g">
				<div class="l-box-lrg pure-u-1 pure-u-md-2-5">
					<form id="form3" onsubmit="return false" class="pure-form pure-form-stacked">
						<fieldset>
							<label for="name3">Логин</label>
							<input id="name3" class="input_login" type="text" placeholder="Ваш логин">
							<label for="pswd3">Пароль</label>
							<input id="pswd3" class="input_pswd" type="password" placeholder="Ваш пароль">
							<div class="questions_container">
								<!--Questions inserts JS-->
							</div>
							<button id="but3" onclick="return pressSubmit('form3','questionare')" class="pure-button">Отправить ответы</button>
						</fieldset><span class="submit_msg faded_elem"></span> </form>
				</div>
				<div class="l-box-lrg pure-u-1 pure-u-md-3-5">
					<h4>Как заполнить:</h4>
					<p> В данной форме можно пройти опросник и получить результаты, если данная услуга оплачена во второй форме. </p>
					<h4>Ожидаемый сценарий</h4>
					<p>Пользователь корректно заполняет форму по критериям:
						<ul>
							<li>все поля формы нужно заполнить</li>
							<li>в поля можно вводить символы A-Z, a-z, 0-9, @ и . (без пробелов)</li>
							<li>нужно ввести правильный пароль для зарегистрированного пользователя, у которого есть запись об оплате</li>
							<li>на один логин может быть записан только один результат опросника</li>
						</ul>
						<h4>Негативные сценарии</h4>
						<p>Пользователь:
							<ul>
								<li>пытается отправить форму с пустыми полями (всеми или частью)</li>
								<li>отправляет данные с другими символами и пробелами</li>
								<li>пробует получить результаты опросника с логином, которого нет в БД</li>
								<li>вводит некорректный пароль для существующего пользователя</li>
								<li>вводит корректные логин и пароль без оплаты</li>
								<li>пробует пройти опросник по одному логину повторно</li>
							</ul> Во всех этих случаях выводится сообщение об ошибке, и либо блокируется отправка формы, либо не сохраняются введённые данные в БД.
							<br/>Если сохранились корректные данные, по ним можно получить всю информацию в последней форме. </div>
			</div>
			<h2 class="content-head is-center">Форма для вывода всех данных</h2>
			<div class="pure-g">
				<div class="l-box-lrg pure-u-1 pure-u-md-3-5">
					<h4>Как заполнить:</h4>
					<p> В данной форме можно получить все данные по всем предыдущим формам. </p>
					<h4>Ожидаемый сценарий</h4>
					<p>Пользователь корректно заполняет форму по критериям:
						<ul>
							<li>все поля формы нужно заполнить</li>
							<li>в поля можно вводить символы A-Z, a-z, 0-9, @ и . (без пробелов)</li>
							<li>нужно ввести правильный пароль для зарегистрированного пользователя, который получил результаты по опроснику</li>
						</ul>
						<h4>Негативные сценарии</h4>
						<p>Пользователь:
							<ul>
								<li>пытается отправить форму с пустыми полями (всеми или частью)</li>
								<li>отправляет данные с другими символами и пробелами</li>
								<li>пробует получить данные для логина, которого нет в БД</li>
								<li>вводит некорректный пароль для существующего пользователя</li>
								<li>вводит корректные логин и пароль без результатов по третьей форме</li>
							</ul> Во всех этих случаях выводится сообщение об ошибке, и либо блокируется отправка формы, либо не выводятся записанные ранее данные из БД.
							<br/>Если сохранились корректные данные, выводится вся информация. </div>
				<div class="l-box-lrg pure-u-1 pure-u-md-2-5">
					<form id="form4" onsubmit="return false" class="pure-form pure-form-stacked">
						<fieldset>
							<label for="name4">Логин</label>
							<input id="name4" class="input_login" type="text" placeholder="Ваш логин">
							<label for="pswd4">Пароль</label>
							<input id="pswd4" class="input_pswd" type="password" placeholder="Ваш пароль">
							<!--Questions inserts JS-->
							<button id="but4" onclick="return pressSubmit('form4','repeatResult')" class="pure-button">Загрузить данные</button>
						</fieldset> <span class="submit_msg faded_elem"></span> </form>
				</div>
			</div>
		</div>
		<div class="ribbon l-box-lrg pure-g last_block">
			<a name="black-box"></a>
			<div class="pure-u-1 pure-u-md-1-2 pure-u-lg-5-5">
				<h2 class="content-head content-head-ribbon">Unit-тестирование Mocha.js & Chai.js</h2>
				<h3 class="content-head content-head-ribbon">Описание проекта</h3>
				<p> Исходные файлы размещены на Github и доступны по <b><a href="https://github.com/aguaBrillante/demotesting" class="text_link">этой ссылке</a></b></p>
				<p> Перейти на страницу с прогоном unit-тестов можно по <b><a href="http://demotesting.space/mocha/mocha-testing.html" class="text_link">этой ссылке</a></b></p>
				<p> Технологии проекта: HTML, Javascript, CSS, PHP и PostgreSQL. Библиотеки и фремворки: Lodash.js, Mocha.js, Chai.js, ajv.js.
					<br/>Javascript представлен тремя файлами:
					<ul>
						<li>DOMadding.js отвечает за динамическую генерацию части контента в HTML,</li>
						<li>script.js обрабатывает отправку форм и выводит в HTML ответы - здесь реализованы основные функции,</li>
						<li>test.js содержит unit тесты по проекту, написанные с помощью фрэймворка Mocha.js и библиотеки Chai.js.</li>
					</ul>
				</p>
				<p> Основная функция в <b>script.js</b> - pressSubmit. Это функция верхнего уровня, которая через вложенные вызовы запускает другие вспомогательные функции - они обеспечивают процесс обработки данных формы, отправку запросов на сервер, получение и вывод ответов. В ходе этого процесса данные хранятся в объекте формы formObj, который генерируется при вызове pressSubmit. То, каким образом обрабатываются данные различных типов форм, определено в статических объектах внутри объекта formTypes, которые вместе с объектом формы formObj участвует в вызове упомянутых функций. Большинство из них вызываются в качестве метода formObj. </p>
				<h3 class="content-head content-head-ribbon">Описание unit-тестирования</h3>
				<p> Для каждой функции в <b>script.js</b> написан блок тестов,которые покрывают 3 группы кейсов:
					<ul>
						<li>Функция вызывается с корректными аргументами в корректном контексте,</li>
						<li>Функция вызывается с некорректными аргументами или в некорректном контексте,</li>
						<li>Функция вызывается без аргументов.</li>
					</ul> Проверки для аргументов позволяют отслеживать некорректные вызовы функций по ходу кода. </p>
				<p> Т.к. разрабатывается модельный JavaScript проект, есть возможность проектировать функции любым способом. В реальных условиях работы нужны более гибкие правила тестирования и разработки, которые согласуются командой проекта - здесь я предлагаю лишь один из подходов, который применяется в условиях «конь в вакууме». </p>
				<p> В первой группе кейсов прорабатываются варианты предусмотренных сценариев и их результатов. Эта группа тестирует категорию пользовательских "ошибок" - пользовательские действия, которые возможны, но не приводят к результату - например, отправка неполной формы или указание неправильного пароля. Для них производится логирование в консоли и вывод сообщения на странице, т.к. они предназначены конечному пользователю. </p>
				<p> Проблемы интеграции функциональных модулей, которые могут приводить к ошибкам скрипта, отсеиваются в следующих группах кейсов - вторая и третья группы кейсов прорабатываются вместе. </p>
				<p> Проектирование функций основано на принципе TDD (test driven development). Чтобы повысить testability функций и улучшить процесс их интеграции, по мере их выполнения осуществляются разные проверки. В начале исполнения кода функции проверяется наличие аргументов и их характеристики. Если нужны определенные данные из контекста, по ходу исполнения кода функции это проверяется. Если эти проверки не проходят, происходит «выброс» ошибки, которая обрабатывается блоком try/catch в функции верхнего уровня (pressSubmit) - она логирует сообщения ошибок в консоли и выводит общее сообщение в форму на странице. Таким способом также «отлавливаются» все встроеные ошибки при выполнении вложенного в try/catch кода.</p> 
				<p>Эти ошибки главным образом используются для отладки интеграции разных частей веб-ресурса: html, js (функций и статических данных). Если pressSubmit срабатывает некорректно, видно какой тест в какой вложенной функции был провален. После качественной отладки и тестирования такие ошибки не срабатывают в рамках пользовательских сценариев. </p>
				<h3 class="content-head content-head-ribbon">Пример unit-тестирования</h3>
				<p> <b>formObj.updatePG</b> - это метод объекта формы, который отправляет SQL запросы на сервер. Функция использует <b>Fetch API</b> и по завершению передаёт текстовый ответ обработчику ответов. Асинхронность обеспечивается с помощью ключевых слов async/await (которые работают на основе промисов). Для данной функции тестируются следующие условия:
					<ol>
						<li> Корректный ответ записывается в свойство объекта формы и используется обработчиком ответа с сервера. Тестируется на уровне интеграции функций в тестах для pressSubmit. </li>
						<li> Аргумент url вложенной функции <b>fetch</b> ссылается на php-файл в корневой директории проекта. Его наличие/корректность проверяется регулярным выражением. Выброс ошибки при некорректном url проверяется unit-тестами. </li>
						<li> Для запуска отпраки запроса на сервер необходим флаг goPost равный true. Он выставляется на внешнем уровне, если предыдущие шаги пройдены успешно. Значение true проверяется в тестах с корректными условиями запроса. Значение false тестируется в отдельном тесте на предмет выброса ошибки. </li>
						<li> SQL statement должен быть не пустой строкой. Корректное значениетестируется в тесте на отправку запроса на сервер. Выброс ошибки при пустой строке тестируется в отдельном тесте. Семантическая корректность запросов проверяется тестами в Postman и с помощью ручного тестирования базы данных c помощью sql запросов. </li>
						<li> Поскольку функция <b>fetch</b> практически всегда возвращает response, даже в случае Bad Request и т.д., отдельная проверка генерирует ошибку, если response.ok === false. Выброс ошибки проверяется unit-тестами. </li>
						<li> Ошибки типа "Failed to fetch" (ex. ошибки CORS policy) "всплывают" и обрабатываются на верхнем уровне функции pressSubmit. Тестируются там же. В тестах этой функции данная проверка дублируется для подтверждения, что в выбранных тестовых условиях срабатывает эта ошибка. </li>
						<li> Для отправки POST запроса определен минимальный состав объекта Headers (второй аргумент функции Fetch). Корректность обработки запросов с этими заголовками проверяется в Postman. </li>
						<li> Текст ответа, который генерирует response.text() должен быть строкой ненулевой длины. Выброс ошибки при нулевой строке проверяется unit-тестами. Семантическая корректность ответа с серрвера проверяется в функции обработки ответа. </li>
					</ol>
					<p> Ниже приведена выдержка из test.js с тестами для метода formObj.updatePG. </p> <img alt="Test image" class="img_1" src="img/testimg.jpg">
					<h3 class="content-head content-head-ribbon">Unit-тестирование: детали</h3>
					<p> Тесты реализованы по принципу модульности: есть общие шаблонные переменные, которые определяют неизменные данные (например, образцы типов данных). </p>
					<p> Группы тестов для каждой функции используют эти переменные, либо объявляются локальные тестовые переменные, не доступные снаружи блока тестов.
						<p> Если тестовые скрипты все же меняют глобальные переменные (например, значение value для тэгов input внутри формы), то изначальные значения восстанавливаются с помощью блоков afterEach и after. </p>
						<p> Таким образом, тестовые группы каждой функции независимы друг от друга и не влияют на глобальное окружение - их содержание/состав/расположение могут меняться любым способом. </p>
						<p> Асинхронные функции проверяются асинхронными тестами. </p>
						<p> Статические данные для обработки разных типов форм хранятся в объекте formTypes. Он проверяется на соответствие шаблону JSON schema при помощи ajv.js плагина - автоматически проверяются новые formType, если такие необходимы. </p>
						<p> По всему проекту также используются вспомогательные функции из библиотеки Lodash.js </p>
						<p> Тщательная проработка и покрытие всех кейсов даёт гибкость и возможность вносить изменения в проект в дальнейшем. </p>
			</div>
		</div>
		<h2 class="content-head is-center">Тестирование REST &amp; SOAP APIs в Postman</h2>
		<div class="pure-g">
			<div class="l-box-lrg pure-u-1 pure-u-md-3-5">
				<h4>REST</h4>
				<p>Для детального знакомства с запросами можно импортировать Postman коллекцию при помощи JSON файла.
					<br/>Можно скачать <b><a href="https://github.com/aguaBrillante/demotesting/blob/master/postman/DEMOTESTING.postman_collection.json" class="dark_link">его</a></b> с моего Github аккаунта.
					<p> Для Postman развёрнута тестовая копия реальной базы (СУБД - PostgreSQL). Проверяются ответы сервера на основе тела запроса. Тело POST запроса - это текст sql запроса для базы данных. Тело ответа - это текстовый ответ, который генерирует php на сервере на основе ответа от БД. Такая модель представляет упрощенную имитацию RESTful API.
						<br/>Для каждой формы запускается один POST запрос в трёх итерациях.
						<ul>
							<li>В первой итерации проверяется ответ в случае записи новых уникальных данных.
								<li>Во второй тестируется ответ с сервера в случае повторов данных в запросе.
									<li>В третьей - ответ при ошибке данных (запись по логину/паролю, которых нет в базе). </ul>
					</p>
			</div>
			<div class="l-box-lrg pure-u-1 pure-u-md-2-5">
				<img width="" alt="Test image" class="img_2" src="img/postmanimg.jpg">
			</div>
			<div class="l-box-lrg pure-u-1 pure-u-md-5-5">
					<p> По каждой итерации для запросов определены переменные в файле data.json, значения из которых вставляются в тело запроса. Пример такого динамического запроса: </p> 
<pre>
"insert into registration ("login","password","email") 
values ('{{regLogin}}','{{regPswd}}','{{regEmail}}');"
</pre>
					<p> Пример данных для итерирования можно посмотреть <b><a href="http://demotesting.space/postman/data.json" class="dark_link">по ссылке.</a></b></p>
					<p> Таким образом каждая итерация со своим набором данных приводит к определнному ответу с сервера. Ответ в каждой итерации тестируется во вкладке "tests". Т.к. при каждой итерации приходит свой ответ - проводятся условные тесты, в зависимости от номера итерации. Пример тестов, группированных по итерациям: </p> 
<pre>
if(pm.iterationData.get("iteration")===1){
	pm.test("response body equal 1",function(){
		pm.response.to.have.body("1");
	});
};
if(pm.iterationData.get("iteration")===2){
	pm.test("response body uncludes 'dublicate key'",function(){
		let bodyText = pm.response.text();
		let check = bodyText.indexOf("dublicate key")
		pm.expect(check==-1).to.be.true;
	});
};
if(pm.iterationData.get("iteration")===3){
	pm.test("response body equal 0",function(){
		pm.response.to.have.body("0");
	});
};
</pre>
					<p>Такая проверка тела ответов с сервера даёт согласованность с обработкой ответов в script.js.</p>
					<h4>SOAP</h4>
					<p>В Postman нет возможности напрямую работать с XML данными, поэтому тестирование SOAP API проводится с помощью конвертации XML в JSON плагином xml2json.js. Далее JSON валидируется с помощью плагина ajv.js по аналогии с XML Schema. </p>
					<p>Примеры тестирования SOAP API - to be continued...</p>
			</div>
		</div>
		<div class="ribbon l-box-lrg pure-g last_block">
			<a name="black-box"></a>
			<div class="pure-u-1 pure-u-md-1-2 pure-u-lg-5-5"> </div>
		</div>
		<div class="footer l-box is-center"> Отправить предложение по вакансии на <a href="mailto:t.yamaltdinova@gmail.com">t.yamaltdinova@gmail.com</a>. </div>
	</div>
	<script src="lodash.js"></script>
	<script src="DOMadding.js"></script>
	<script src="script.js"></script>
	<script src="draft.js"></script>
</body>

</html>